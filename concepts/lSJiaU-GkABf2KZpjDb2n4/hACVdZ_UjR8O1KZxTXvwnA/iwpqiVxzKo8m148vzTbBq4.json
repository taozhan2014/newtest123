{
  "uri" : "local://iwpqiVxzKo8m148vzTbBq4/",
  "name" : "Unit 8: Update APIs and integration with jQuery and KnockoutJS",
  "category" : "unit",
  "parent" : "local://hACVdZ_UjR8O1KZxTXvwnA/",
  "pname" : "Course 101",
  "flags" : "U",
  "lvars" : [ ],
  "vars" : [ {
    "name" : "_unit_name",
    "expr" : {
      "str" : "Update APIs and integration with jQuery and KnockoutJS"
    }
  }, {
    "name" : "_unit_content",
    "expr" : {
      "str" : "<blockquote>\n<p>There is nothing permanent except change.\n\n<footer>Heraclitus, philosopher, 535-475 BC</footer>\n</blockquote>\n\n<h3>Update APIs</h3>\n\n<p>The previous section discussed how client and server-side scripts can query concepts with nearly-identical APIs. This section describes how you can update concepts using client and server-side scripts. We also look at how ConceptJS pages can use <a href=\"http://jquery.com/\" target=\"_blank\">jQuery</a> and <a href=\"knockoutjs.com\" target=\"_blank\">KnockoutJS </a> frameworks. \n\n<p>The update methods in concept and property objects are very similar to the query methods. The following table shows the various methods related to updating concepts. \n\n<hr>\n\n<table class=\"table table-hover\">\n<thead>\n<tr><th>Method <th>Supported by concept? <th>Supported by property? <th>Return Value <th>Return Type\n</thead>\n\n<tbody>\n<tr><th>name(newName) <td><i class=\"fa fa-check\"></i> <td> <td>Updates the name of the concept and returns <tt>this</tt>  <td>Concept object\n\n<tr><th>category(newCat)<td><i class=\"fa fa-check\"></i> <td> <td>Sets category of the concept to the given category, and returns <tt>this</tt>.  <td>Concept object\n\n<tr><th>parentUri([uri]) <td><i class=\"fa fa-check\"></i> <td> <td>Updates the parent of this concept and return <tt>this</tt>. If the uri is null, the concept is placed under the root concept of the repository. This method does not work for bound concepts. <td>Concept object\n\n<tr><th>val(newValue) <td> <td><i class=\"fa fa-check\"></i> <td>Sets the value to the given value, and return <tt>home()</tt>. You can chain the value setters as concObj.prop('foo').val(1).prop('bar').val('two'). <td>Concept object\n\n<tr><th>prop(propName, newValue) <td><i class=\"fa fa-check\"></i> <td><i class=\"fa fa-check\"></i> <td>Shortcut for prop(propName).val(newValue). You can chain the value setters as concObj.prop('foo', 1).prop('bar', 'two'). <td>Concept object\n\n<tr><th>source() <td> <td><i class=\"fa fa-check\"></i> <td>Returns the property object which is the source for this property. The <tt>val()</tt> and <tt>prop()</tt> setter methods listed above use this method to \"track down the source\" which is then updated. <td>Property object\n\n<tr><th>isModifiable()<td><td><i class=\"fa fa-check\"></i> <td>Returns whether/not the source of this property can be modified by the owner of this concept. <td>Boolean\n\n<tr><th>canUpdate()<td><i class=\"fa fa-check\"></i> <td> <i class=\"fa fa-check\"><td>Returns whether/not the current user can update the values in this concept. For properties, <tt>canUpdate</tt> is shortcut for <tt>isModifiable() && anchor().canUpdate()</tt><td>Boolean\n\n<tr><th>del()<td><i class=\"fa fa-check\"></i> <td> <td>Deletes a concept and its descendants. <td>\n\n</tbody>\n</table>\n\n<hr>\n\n<p>As you can see the method signatures are very similar to the query API, except that an argument specifies the new value. Furthermore, every update (setter) method returns back the same concept/property object. This is useful when you are chaining updates. The following example illustrates the first five methods chained together: \n\n<pre>\n// jQuery style method chaining\n$cjs(\"...some concept uri...\").name(\"new name\").category(\"new category\").parentUri(\"...new concept uri...\").prop('foo').val('1').prop('bar', 'two');\n</pre>\n\n<p>The above code updates the name, category, parent and the properties 'foo' and 'bar'. \n\n<hr>\n\n<h3>How updates work</h3>\n\n<p>The update APIs don't work on every property in a simple or bound concept. The system first tracks down the source of the property, then checks to see certain conditions are met at the source, and finally updates the property.  \n\n<p>Let's consider an <a href=\"/idelocal://lYj6zM_lxu8B143dhrrd08/\" target=\"_blank\">Example lambda-concept showing addition</a> that takes two numeric lambda-properties 'a' and 'b' and computes a 'result' that contains a + b. This lambda-concept is used by the concept <a href=\"/idelocal://VpouAIszww8jSaog5MUnSF/\" target=\"_blank\">ThreePlusFour</a> that computes 3 + 4 and sets it the result to its local property 'seven'. You can use the debugger to see how ThreePlusFour works. \n\n<p>In the rest of the section, we will see why only ThreePlusFour.three and ThreePlusFour.add.a can be updated by the owner of this concept. In both cases, the updates will change ThreePlusFour.three. \n\n<h4>Tracking down the source</h4>\n\n<p>To find out whether a property is modifiable, the system tracks down the source of the property, which can be accessed using the <tt>source</tt> method. \n\n<p>The following script tracks down the source for all the properties of ThreePlusFour. \n\n<hr>\n\n<p><div class=\"row iScript\">\n<div class=\"col-xs-12 col-sm-6\">\n  <textarea rows=\"5\" class=\"form-control iScriptTxt\" id=\"\">(function() {\n  var conc = $cjs(\"local://VpouAIszww8jSaog5MUnSF/\");\n  return _.map(conc.propNames(), function(name) { \n    return name + \" -> \" + conc.prop(name).source().uri() }).join(\"\\n\");\n})();</textarea>\n</div>\n<div class=\"col-xs-12 col-sm-1\">\n  <button class=\"btn btn-default iScriptBtn\">Run <i class=\"fa fa-arrow-right\"></i></button>\n</div>\n<div class=\"col-xs-12 col-sm-5\">\n  <pre class=\"iScriptResult\">Click Run</pre>\n</div>\n</div>\n\n<hr>\n\n<p>The source is the same URI, except for 'seven' which is looked up from ThreePlusFour.add.result. \n\n<p><b>Exercise 1: </b>Find the sources of all properties in ThreePlusFour.add. <i>Hint:</i> You only need to change the URI in line 2. \n\n<p>You can see that the lambda-properties of ThreePlusFour.add point to the simple properties of ThreePlusFour. This is called <i>tracking down the source</i>. In other words, any update to ThreePlusFour.add.a and ThreePlusFour.add.b will reflect in ThreePlusFour.three and ThreePlusFour.four (respectively). \n\n<h4>Conditions checked before an update</h4>\n\n<div class=\"well well-sm sidenote\">\n<p><i>Adapting the UI to the user's permissions</i>: The <tt>canUpdate</tt> method can help you develop pages and widgets that show a read-only version to certain users, and a read-write version to others. \n\n<p>A repository in ConceptJS is, by default, readable by everyone and only writeable by you. You can assign write permissions to users you trust using your User Settings pages. \n</div>\n\n<p>A property is updateable only if all the following conditions are met for its: <ol>\n<li>The source is a simple property belonging to a simple concept. \n<li>The source is an expression of the type String, Boolean, Number, JSON or Concept, provided the Concept is a simple concept. \n<li>The new value being set belongs to the same type as the source. \n<li>The user has permissions to write to that concept. \n</ol>\n\n<p>The first three conditions are checked by <tt>isModifiable</tt> and all the conditions are checked by <tt>canUpdate</tt>. The <tt>isModifiable</tt> and <tt>source</tt> methods are provided to help understand if an update operation will work. The <tt>canUpdate</tt> method is what determines whether a property can be updated or not.\n\n<p>The following script checks to see if properties of ThreePlusFour can be modified by their owner. \n\n<hr>\n\n<p><div class=\"row iScript\">\n<div class=\"col-xs-12 col-sm-6\">\n  <textarea rows=\"5\" class=\"form-control iScriptTxt\" id=\"\">(function() {\n  var conc = $cjs(\"local://VpouAIszww8jSaog5MUnSF/\");\n  return _.map(conc.propNames(), function(name) { \n    return name + \" -> \" + conc.prop(name).isModifiable() }).join(\"\\n\");\n})();</textarea>\n</div>\n<div class=\"col-xs-12 col-sm-1\">\n  <button class=\"btn btn-default iScriptBtn\">Run <i class=\"fa fa-arrow-right\"></i></button>\n</div>\n<div class=\"col-xs-12 col-sm-5\">\n  <pre class=\"iScriptResult\">Click Run</pre>\n</div>\n</div>\n\n<hr>\n\n<div class=\"well well-sm sidenote\">\n<i>Scripts can be updated</i>: Property lookups and simple expressions such as String, Number, Boolean and JSON are preferable to script expressions if you want to build a updateable concept. \n</div>\n\n<p><b>Exercise 2: </b>Check to see if lambda-properties of ThreePlusFour.add can be updated. <i>Hint: </i>Like with the previous exercise, you just have to change the URI. \n\n<p>The following list shows how various properties fail the above condition checks: <ul>\n<li>ThreePlusFour.seven and ThreePlusFour.add.result fail condition #1 because they refer to a property inside a bound concept. \n<li>ThreePlusFour.four and ThreePlusFour.add.b fail condition #2 because they refer to a script expression (<tt>return 4</tt>).\n<li>You can not set the value of ThreePlusFour.three to a String even if you had permissions, because of condition #3. \n<li>Because of condition #4, you will need access to the <tt>/common/univ</tt> repository to change ThreePlusFour.three or ThreePlusFour.add.a. \n</ul>\n\n<hr>\n\n<h3>Building read-write web pages using jQuery</h3>\n\n<p>You can build read-write pages using jQuery event handlers. Whenever any property changes, you can call <tt>$cjs(\"...\").val(...newValue...)</tt> to update the value of that property within the session. In manual save mode, this prompts the Save and Discard buttons. In the \"script\" mode, you will have to explicitly call <tt>$cjs.session.save()</tt> which is covered in the next section. \n\n<hr>\n\n<h3>Top-level update APIs</h3>\n\n<p>The following methods are directly available in the global $cjs variable: \n\n<br>\n<table class=\"table table-hover\">\n<thead>\n<tr><th>Method<th>Arguments <th>Description<th>Return Type\n</thead>\n\n<tbody>\n<tr><th>newConcept <td>Object with the following attributes: <ul>\n<li><b>puri: </b> the parent uri of the new concept\n<li><b>ruri: </b> the repository uri of the new concept. Either puri or ruri need to be provided in order to create a new concept\n<li><b>concept: </b> a concept JSON to be used for the new concept. If missing, an empty concept will be created.\n<li><b>done: </b> callback function if creation is successful. If missing, the method will be a synchronized call and will return the new concept object\n<li><b>fail: </b> callback function in case of failure</ul> \n<td>This method creates a new concept <td>Concept object\n\n<tr><th>copyConcept <td>Object with the following attributes: <ul>\n<li><b>puri: </b> the parent uri of the new concept.\n<li><b>curi: </b> the uri of the concept that is to be copied from\n<li><b>keepName: </b> if true, preserves the name of the original concept\n<li><b>newName: </b> if set, this will be the name of the copied concept\n<li><b>done: </b> callback function if the operation is successful. If missing, the method will be a synchronized call and will return the copied concept object\n<li><b>fail: </b> callback function in case of failure</ul> \n<td>This method creates a new concept copied from an existing concept <td>Concept object\n\n<tr><th>moveConcept <td>Object with the following attributes: <ul>\n<li><b>curi: </b> the uri of the concept to be moved\n<li><b>puri: </b> the new parent uri the concept is moved to\n<li><b>done: </b> callback function if the operation is successful. If missing, the method will be a synchronized call and will return the moved concept object\n<li><b>fail: </b> callback function in case of failure</ul> \n<td>This method moves an existing concept to a new parent and returns the moved concept <td>Concept object\n\n<tr><th>downloadCopy <td>Object with the following attributes: <ul>\n<li><b>copyUri: </b> the uri of the concept to download\n<li><b>newName: </b> if set, this will be the name of the downloaded concept\n<li><b>done: </b> callback function if the operation is successful. If missing, the method will be a synchronized call\n<li><b>fail: </b> callback function in case of failure</ul> \n<td>This method downloads an existing concept to the default repository of the current login user<td>Undefined\n\n<tr><th>deleteChildren <td>Object with the following attributes: <ul>\n<li><b>puri: </b> the uri of the parent concept of the children to be deleted\n<li><b>category: </b> if set, only children with specified category will be deleted\n<li><b>done: </b> callback function if the operation is successful. If missing, the method will be a synchronized call\n<li><b>fail: </b> callback function in case of failure</ul> \n<td>This method deletes all children of a specified parent concept. Optional category attribute can be used to delete only children with certain category<td>Undefined\n\n<tr><th>clearCache <td>\n<td>This method clear all client-side cache objects <td>Undefined\n</tbody>\n</table> \n\n<hr>\n\n<h3>The <tt>$cjs.session</tt> object and the <tt>cjsSaveMode</tt> meta directive</h3>\n\n<p>In the previous video, we saw how the Person lambda-concept can have an editable human-readable form. However, you probably noticed the Save and Discard buttons in the top of the page. This is the default behavior when you make changes to the concept &mdash; an easy way for the system to let you manage if/when you save the changes. \n\n<p>However, there are many cases where you want to deal with saving/discarding the changes yourself. In this case, you can add the following <tt>meta</tt> tag in your HTML Page to make sure that the Save and Discard buttons don't appear. \n\n<pre>\n&lt;head&gt;\n  ...\n  &lt;meta name=&quot;cjsSaveMode&quot; content=&quot;script&quot;&gt;\n  ...\n&lt;/head&gt;\n&lt;body&gt;\n  ...\n&lt;/body&gt;\n</pre>\n\n<p>You will then have to use the <tt>$cjs.session</tt> methods: <ol>\n<li><b><tt>$cjs.session.save()</tt></b>: Saves all changes made using the update APIs to the server. \n<li><b><tt>$cjs.session.discard()</tt></b>: Discards all changes made to the server. You will typically have to refresh the whole page so that the widgets are in sync with the server-side information. \n<li><b><tt>$cjs.session.hasChanges()</tt></b>: Checks whether there are changes to be saved. This is useful only if you have an automatic save based on polling. \n</ol>\n\n<p>The next unit discusses integration with KnockoutJS. \n\n<hr>\n\n<h3>Integration with KnockoutJS</h3>\n\n<div class=\"well well-sm sidenote\">\n<p><i>This page uses KnockoutJS</i>: You can view the source of this frame. You can scroll down and look at the Javascript code in CourseModel. This is the view-model for all functions in this page such as the progress bar, navigation buttons, etc. \n</div>\n\n<p><a href=\"http://www.knockoutjs.com\" target=\"_blank\">KnockoutJS</a> is a wonderful MVVM Javascript framework that dramatically simplifies dynamic Javascript UIs. There is a very nice <a href=\"http://learn.knockoutjs.com/\" target=\"_blank\">tutorial</a> that you can get started on the framework. ConceptJS provides some useful APIs that make it easy for your UIs to leverage Knockout. If you are more comfortable with jQuery, you can skip the rest of the section. \n\n<p>The key idea behind Knockout is to use <i>observables</i> in ViewModel objects and tie them to widgets such as textboxes. Now, any change to the view-model is reflected in the view, and vice-versa. In other words, if I tie a string property in the ViewModel to a textarea, then that string is reflected in the textarea on page-load, and any updates to that textarea is reflected back in the string. \n\n<p>What if you could directly tie the string property in the ViewModel to a string property in a concept? Now you don't have to worry about the query and update APIs. This is exactly what the Knockout APIs let you do. \n\n<p>The following video shows how you can create an editable page for the Programmer lambda concept. \n\n<br>\n\n<p><figure style=\"text-align: center\">\n<iframe src=\"//fast.wistia.net/embed/iframe/u87wosi5fx\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen mozallowfullscreen webkitallowfullscreen oallowfullscreen msallowfullscreen width=\"854\" height=\"460\"></iframe>\n</figure>\n\n<br>\n\n<p>The <tt>$cjs.ko</tt> object is responsible for KnockoutJS-integration. \n\n<h4>A single concept model with knockout observable</h4>\n\n<b>$cjs.ko([concept/property URI]): </b> This method returns a ConceptViewModel for the simple or bound concept with the given URI, with the given knockout observable properties: <ol type=\"a\">\n  <li><b>uri: </b> Read-only computed function that returns the URI\n  <li><b>url: </b> Read-only computed function that returns the relative URL to the /view page\n  <li><b>name: </b> Read-only computed function that returns the name of the concept\n  <li><b>category: </b> Read-only computed function that returns the category of the concept\n  <li><b>puri: </b> Read-only computed function that returns the parent uri of the simple concept or anchor concept if the uri points to a bound concept\n  <li><b>anchorUri: </b> Read-only computed function that returns the uri of the anchor concept if the uri points to a bound concept\n  <li><b>&lt;property-name&gt;: </b> Read-only or read-write computed function that captures the value of the concept property corresponding to <tt>.val()</tt>. You can use ko.isWriteableObservable() to determine if this property can be overwritten. All writes are saved using the <tt>.val([newValue])</tt> method. \n</ol>\n\n<h5>Another example</h5>\n\n<p>You can take a look at the <a href=\"/ide/common/core/m_jbKs409s86K4IBVBn3EB/\" target=\"_blank\">Chemical Element View</a>, specifically the htmlTemplate property, to see how the single concept model and KnockoutJS integration works. \n\nThe code snippet below shows how to bind a chemical element concept Magnesium with knockout view model. In addition to the default concept properties, you can add any other computed observables like the \"wikiDataLink\" below.\n<pre>\n  var cvm = $cjs.ko('/common/core/-mhi9Iidz6AZtKs_oNHGc5/element');\n  cvm.wikiDataLink = ko.computed(function() {\n      return 'http://www.wikidata.org/wiki/' + cvm.wikiDataID();\n    }, cvm);\n\n  ko.applyBindings(cvm);\n</pre>\n\nAfter the binding you can use any concept property in the UI widgets as knockout observables. Any change to the binding property will be automatically saved in ConceptJS when you click Save button or make \"$cjs.session.save()\" call.\n<pre>\n&lt;input type=\"text\" class=\"form-control\" placeholder=\"enter symbol\" data-bind=\"textInput: symbol\" value=\"\" size=\"10\" style=\"width:auto;\"&gt;\n</pre>\n\n<h4>Children concepts model with knockout observable array</h4>\n\n<b>$cjs.ko([parent URI], {options}): </b> This method returns a knockout observable array. Each element in the array is a ConceptViewModel that binds to the corresponding child concept. The supported options are:\n<ol>\n    <li><b>children: </b> True if you want to obtain an array of children view model, false if you want to obtain the single concept view model. Default value is false.\n    <li><b>castUri [optional]:</b> The concept URI of an is-a match for the child concept\n    <li><b>category [optional]:</b> If specified, only children with certain category will be returned\n    <li><b>childTemplateUri [optional]:</b> The concept URI of the template used to create a new child. You can also pass the template uri as the argument when you add a new child with the knockout observableArray using \"observableArray.push(uri)\". However, either global childTemplateUri or uri argument need to be specified in order to be able to add new child. \n    <li><b>childVM [optional]: </b> If specified, the provided childVM will be used instead of default ConceptViewModel. However, the build-in ConceptViewModel for that element will be passed as the first argument of the childVM construct function. Please see example below.\n    <li><b>errorOnWrite [optional]: </b> If true, Read-only knockout computed function will be used if the user doesn't have access privilege to the concept property. Error will be thrown if you try to set the value of the property via knockout binding. Set it to false will allow knockout bindings to modify the property values, however, $cjs.sesssion.save() will fail if the user doesn't have enough privileges\n</ol>\n\n<h5>A Example</h5>\n\n<p>You can take a look at the <a href=\"/ide/common/core/20ahtp-ncj88T4Pf-Iyqc0/\" target=\"_blank\">Contact View</a>, specifically the htmlTemplate property, to see how the children concepts and KnockoutJS integration works. \n\nThe code snippet below shows how to bind emails of a contact concept with knockout.\n<pre>\n    function ContactModel(){\n        var self = this;\n        ...\n        self.emails = $cjs.ko('/common/core/pqicq3vlxmAsq4PIWuSax1/', {\n            castUri: \"/common/core/2kW2TZfZdDApm4NF6HkNtA/\",\n            children: true,\n            category: \"email\",\n            childTemplateUri: \"/common/core/KnhOryu1JxAVmqEfZAoV3B/\"\n        });\n       ...\n    }\n\n    ko.applyBindings(new ContactModel());\n</pre>\n\nAfter the binding you can use emails like all other knockout ObservableArray. \n<pre>\n&lt;table&gt;\n    &lt;tbody data-bind=\"foreach: emails\"&gt;\n        &lt;tr&gt;\n            &lt;td&gt;&lt;input type=\"email\" class=\"form-control inline input-sm\" id=\"exampleInputEmail1\" placeholder=\"email address\" title=\"email address\" data-bind=\"value: email\" style=\"width: 300px;\"&gt;&nbsp;&lt;a href=\"javascript:void(0);\" class=\"fa fa-times-circle fa-lg\" data-bind=\"click: $parent.removeEmail\"&gt;&lt;/a&gt;\n           &lt;input id=\"\" type=\"checkbox\"  data-bind=\"checked: isWork\"&gt; &lt;label&gt;Work&lt;/label&gt; \n           &lt;input id=\"\" type=\"checkbox\"  data-bind=\"checked: isHome\"&gt; &lt;label&gt;Home&lt;/label&gt; &lt;/td&gt;\n       &lt;/tr&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;\n</pre>\n\nTo add or remove a child, simply use \"emails.push(uri)\" and \"emails.remove(item)\" (uri is the new concept template uri or any string if you provided default childTemplateUri when calling $cjs.ko()). All changes will be automatically saved in ConceptJS when you click Save button or make \"$cjs.session.save()\" call.\n\n<h5>Another Example</h5>\n\n<p>Another more complex example is <a href=\"/ide/common/core/pY4Jk0R5tRAXBK2uq511a3/\" target=\"_blank\">Wishlist View</a>. In this case the custom childVM is used instead of the default ConceptViewModel. \n\nThe code snippet below shows how to bind items of a wishlist with knockout using a custom childVM:\n<pre>\n    function ItemVM(cvm){\n        var self = this;\n        this.cvm = cvm;\n                \n        this.itemId = ko.computed(function(){\n            var uris = purl(cvm.uri());\n            return uris.segment()[2];\n        }, this);\n                \n        this.prettySubmitDate = ko.computed(function(){\n            return \"submitted \" + prettyDate(new Date(Date.parse(this.cvm.submitTime())));\n        }, this);\n\n        ...\n    }\n\n    function WishlistVM(){\n        var self = this;\n                \n        this.wishlist = $cjs.ko(anchorUri);\n\n        self.items = $cjs.ko(anchorUri, {\n                    castUri: \"/common/core/AefSjI1HPpA9faYHYquQU1/\",\n                    children: true,\n                    category: \".item\",\n                    childTemplateUri: \"/common/core/YBAg0cDoIC8ceqJu3w6alF/\",\n                    childVM: ItemVM,\n                    errorOnWrite: false\n                });\n         ...\n    }\n    ko.applyBindings(new WishlistVM());\n</pre>\n\nYou can now bind the concept properties in your html with \"cvm.xxx\" in the \"for-each\" loop or you can define \"this.xxx = cvm.xxx\" in your ItemVM and bind the html with \"xxx\" directly. To add or remove a child, simply use \"items.push(uri)\" and \"items.remove(item)\". Alternatively, you can also create the new child concept explicitly and pass it as a new element in the array as shown below:\n\n<pre>\n   var cvm = $cjs.ko(uri);\n   var newKOItem = new ItemVM(cvm)\n   self.items.push(newKOItem);\n</pre>\n\n<hr>\n\n<h3>Server-side updates using Proxy Methods</h3>\n\n<p>So far, we have looked at updates from client-side scripts. We saw how you can build dynamic Javascript UIs with jQuery and KnockoutJS. All changes by the user are saved into the concept. In this unit, we will look at how you can update concepts using server-side scripts. \n\n<p>Script expressions in properties can not update concepts. For this, you need <b>proxy methods</b>. Proxy methods can be added to a concept using the \"Edit Concept Details\" section of the Editor. \n\n<hr>\n\n<div class=\"panel panel-default\">\n  <div class=\"panel-heading\">\n    <h3 class=\"panel-title\">\n      <a data-toggle=\"collapse\" href=\"#asideWsemkcc\">\n        <i class=\"fa fa-caret-right\"></i> Deep dive: Why aren't script expressions allowed to perform updates? \n      </a>\n    </h3>\n  </div>\n\n  <div id=\"asideWsemkcc\" class=\"panel-collapse collapse progPanel\">\n    <div class=\"panel-body\">\n\n<p>Script expressions are not allowed to update concepts. For example, I can not have a concept where a property (say) 'a' is set to 1 and the next property 'b' has a script to increment the value of 'a'. The reason for this is that we would like to limit <a href=\"https://en.wikipedia.org/wiki/Side_effect_(computer_science)\" target=\"_blank\">side effects</a>. \n\n<p><blockquote>\nIn the presence of side effects, a program's behavior may depend on history; that is, the order of evaluation matters. Understanding and debugging a function with side effects requires knowledge about the context and its possible histories.\n<footer>From the Wikipedia article on Side Effects</footer>\n</blockquote>\n\n<p>With ConceptJS, we want to be able to evaluate and re-evaluate concepts any number of times, without causing things to change. So we do not allow script expressions in properties perform updates. \n    </div>\n  </div>\n</div>\n\n<hr>\n\n<h4>Use-cases for proxy methods</h4>\n\n<p>There are some concrete use-cases when you will need proxy methods: <ol>\n<li><b>The user can not be trusted with write permissions: </b>Consider a blog entry where you want your readers to post comments. You can not give everyone write permissions, because someone might just overwrite your blog. The workaround is to create a proxy method called <tt>comment()</tt>, that the Javascript client can invoke on the concept. This method acts as a \"proxy\" for the user's client. \n\n<li><b>The logic to validate the operation is non-trivial: </b>Consider a concept for a checkers game. The game is played by two players. Each player needs to take a turn. Now, we can model this logic in Javascript, and risk that a player might simply change the rules and make a couple of moves at once. The other option is to write a proxy called <tt>move()</tt> that has the logic to see which user's turn it is to move before making any changes to the board. \n</ol>\n\n<h4>An example</h4>\n\n<p>You can take a look at the <a href=\"/idelocal://vhTY4TXKDyBf0qeJc8k1pD/\">Example showing a proxy method <i class=\"fa fa-external-link\" target=\"_blank\"></i></a>. The \"Edit Concept Details\" section in the editor will show you the proxy method named foo. This method increments the 'counter' property and keeps track of the last user name and the last comment made by the user. \n\n<p>Now, you can add your own comment to the concept, even though you don't have write permissions. The following script posts a comment called \"Check this out\". This will get saved in the 'lastComment' property, and the counter will get incremented. \n\n<hr>\n\n<p><div class=\"row iScript\">\n<div class=\"col-xs-12 col-sm-6\">\n  <textarea rows=\"5\" class=\"form-control iScriptTxt\" id=\"\">(function() {\nvar conc = $cjs(\"local://vhTY4TXKDyBf0qeJc8k1pD/\");\nvar response = conc.execute(\"foo\", {\"comment\": \"Check this out\"});\nreturn \"Response: \" + JSON.stringify(response, null, 2);\n})();\n</textarea>\n\n</div>\n<div class=\"col-xs-12 col-sm-1\">\n  <button class=\"btn btn-default iScriptBtn\">Run <i class=\"fa fa-arrow-right\"></i></button>\n</div>\n<div class=\"col-xs-12 col-sm-5\">\n  <pre class=\"iScriptResult\">Click Run</pre>\n</div>\n</div>\n\n<hr>\n\n<p>You can go back to the editor to see how the 'lastUser', 'counter' and 'lastComment' properties have changed. You can also play with the comment to see how any comment can be sent across to the server. Remember to refresh the concept in the editor to see the latest changes. \n\n<hr>\n\n<h3>Recap</h3>\n\n<ol class=\"recap\">\n<li>The update APIs in the <tt>$cjs</tt> object are very similar to the query APIs. \n<li>You can build read-write pages by invoking the update operations in callback functions in jQuery, when the user makes changes to the concept. \n<li>The <tt>$cjs.session</tt> object has methods to detect, save, discard changes made by the user, in case you don't want to use the pre-build save/discard functionality. \n<li>The <tt>$cjs.ko</tt> object lets you integrate the query and update APIs with KnockoutJS. \n<li>Script expressions in properties can not make any updates to a concept. For this, you need proxy methods which can be added in the \"Edit Concept Details\" section of the editor. \n<li>You can use proxy methods to perform secure and validated changes to a concept on behalf of users who don't have write permissions on the concept. \n</ol>\n\n<script>\n$(function() {\n  $(\".iScriptBtn\").click(function() {\n    var script = $(this).closest(\".iScript\").find(\".iScriptTxt\").val();\n    var result = '';\n    try {\n      result = eval(script);\n    } catch (err) {\n      result = \"Exception: \" + err;\n    }\n    $(this).closest(\".iScript\").find(\".iScriptResult\").text(result);\n  });\n});\n</script>\n\n"
    }
  }, {
    "name" : "_unit_number",
    "expr" : {
      "num" : 8
    }
  }, {
    "name" : "unit",
    "expr" : {
      "concept" : "local://vKVuPLJ9zC82y44Ofqyf85/",
      "conceptName" : "Course Unit",
      "bindings" : {
        "name" : "_unit_name",
        "content" : "_unit_content",
        "number" : "_unit_number"
      }
    }
  } ],
  "isas" : [ {
    "var" : "unit"
  } ],
  "isLambda" : false,
  "digest" : "VUfApEyjmlCU8YlCSWzgbg=="
}