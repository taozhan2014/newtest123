{
  "uri" : "local://gXho_s_umN8YzaNh6-YBbF/",
  "name" : "Unit 9: Advanced UI features",
  "category" : "unit",
  "parent" : "local://61VaKe6zRtAdYqlaAgHs2E/",
  "pname" : "Course 100",
  "flags" : "U",
  "lvars" : [ ],
  "vars" : [ {
    "name" : "_unit_name",
    "expr" : {
      "str" : "Advanced UI features"
    }
  }, {
    "name" : "_unit_content",
    "expr" : {
      "str" : "<p>In this unit, we will improve the performance of the contacts list. We will then add UI features that let users add and delete contacts in the presentation mode. At the end of the unit, we will have built a small contacts management app. \n\n<h3>Lazy evaluation with continuations</h3>\n\n<p>One of the problems with the contacts management application from the previous unit is that the contacts list requires the system to evaluate all the child concepts. During this process, the platform will end up calculating the HTML page representations of all the concepts, and will then throw these away because the contact list only accesses the first/last names and email address. \n\n<p><em>Continuations provide a simple mechanism to delay computations until they are explicitly requested. </em>A continuation is a lambda-concept that has exactly one lambda-property. This is referred to as the <em>input to the continuation</em>. By establishing an is-a relationship to a continuation, a concept declares itself to be everything that the continuation is, as defined by indirect is-a relationships. However, the continuation will not be evaluated unless there is an explicit request for that is-a relationship. \n\n<p>In the contacts management app, we can use a continuation called \"Contacts View\" to capture all the computations required to turn the first/last name and email address to a HTML Page. This is similar to the separation of a view from a model in the MVC architecture. You can do this with the following steps: <ol>\n<li>Copy-paste the \"Contact\" lambda-concept under itself using the Finder. \n<li>Rename the pasted concept to \"Contact View\". This will concept will now take care of rendering the Concept has a HTML page. \n<li>Remove all the lambda-properties from the \"Contact View\" concept, viz. firstName, lastName and email, using the <span class=\"fa fa-times-circle\"></span> icon next to them in the \"Lambda Properties\" section. \n<li>Add a lambda property called <tt>model</tt> and set it to a concept of type \"Contact\". Make sure that you are referring to the Contact in your repository. \n<li>Remove the <tt>namedConcept</tt> property and is-a relationship, using the <span class=\"fa fa-times-circle\"></span> icon next to them in the \"Simple Properties\" and \"Is-Relationship\" sections.  \n<li>Select the <tt>page</tt> property and change the propertyMap binding to return as follows: \n<pre>\nCHANGE\n  return {uri: home.uri()};\nTO \n  return {uri: home.prop('model').uri();}\n</pre>\n<p>This passes the model's URI into the Knockout model so that the first name, last name and email can be loaded properly. \n<li>Save the changes made to the \"Contact View\". This completes the definition of the continuation. \n<li>Open the \"Contact\" concept in the Editor. \n<li>Remove the <tt>htmlTemplate</tt> property, and the <tt>page</tt> property and is-a relationship, from the \"Contact\" concept using the  <span class=\"fa fa-times-circle\"></span> icon next to them. \n<li>Add a new is-a relationship of type \"Concept\" (not \"Property\"), and set the concept to \"Contact View\". As before, make sure that you are referring to the \"Contact View\" in your repository. \n<li>Save the changes made to \"Contact\". We have now linked the \"Contact\" to the \"Contact View\". Because the \"Contact View\" has exactly one lambda-property, the contact itself is passed into this continuation. In this case, the <tt>model</tt> property of the \"Contact View\" will have a reference to the contact. \n<li>Refresh the \"Custom Contacts List\" to make sure that it works as expected. Also, check to see that the sample contacts under the folder work as expected. \n</ol>\n\n<p>The following video demonstrates the above steps, after a brief discussion on the need for the \"Contact View\" continuation: \n<hr>\n<iframe src=\"//fast.wistia.net/embed/iframe/lf3xw8piem?videoFoam=true\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen mozallowfullscreen webkitallowfullscreen oallowfullscreen msallowfullscreen width=\"854\" height=\"463\"></iframe><script src=\"//fast.wistia.net/assets/external/iframe-api-v1.js\"></script>\n<hr>\n\n<h4>How this works</h4>\n\n<p>In this section, we have essentially moved all the logic involved in calculating the HTML representation of the \"Contact\" into a separate concept called \"Contact View\". Because of the transitive nature of the is-a relationship, all contacts behave like the way they did before. The above video shows how the continuation works by opening a contact in the Debugger. \n\n<p>The Contact View is not calculated unless there is an explicit request for a Contact &ldquo;as&rdquo; a HTML page. Specifically, the Custom Contacts Folder which refers to the <tt>as(\"...contact URI...\")</tt> does not trigger an evaluation of the Contact View. But if the concept is opened in the Viewer, the ConceptJS platform triggers an call to the <tt>as(\"...HTML page URI...\")</tt> in the Contact concept, which in turn evaluates the Contact View. \n\n<h4>Reasons to use continuations</h4>\n\n<p>There are three main reasons to use continuations: <ol>\n<li><em>Improving performance:</em> Continuations aren't evaluated unless there is an explicit request to an is-a relationship defined by it, such as HTML Page. \n<li><em>Separation of concerns: </em>You can use continuations to move the code related to generating an is-a relationship to a separate concept. For example, the \"Contact View\" concept described in this unit separates the logic for the view from the underlying data model in Contact. \n<li><em>Avoiding cyclic dependencies: </em>ConceptJS doesn't evaluate concepts that have cyclic dependencies to themselves through other concepts. You can avoid such dependencies by moving some of the code into lazily-evaluated continuations. \n</ol>\n\n<h3>Add button to create new contacts</h3>\n\n<p>In this section, we will add a button in the Contact List to automatically add new contacts. Previously, we have had to go to the Finder to copy-paste example concepts. We will now automate this process. \n\n<p>You can add a button to the Contacts List page using the following steps: <ol>\n<li>Copy-paste an example contact at the same level as the \"Custom Contacts Folder\" and set its name to \"Empty Contact\".\n<li>Open the \"Empty Contact\" in the Editor and select the <tt>contact</tt> property. Set the firstName, lastName and email bindings to empty strings. \n<li>Save the changes made in the Editor. This empty contact concept will be copied each time a new contact is created. \n<li>Open the \"Custom Contacts Folder\" concept in the Editor, and edit the <tt>htmlTemplate</tt> property. Insert a &lt;button&gt; tag in the &lt;h2&gt;Contacts List&lt;/h2&gt; as shown below: \n<pre>\n  ...\n  &lt;h2&gt;Contacts List\n    &lt;button id=\"addBtn\" class=\"btn btn-primary btn-sm\" style=\"margin-left: 3em\"&gt;Add Contact&lt;/button&gt;\n  &lt;/h2&gt;\n</pre>\n<li>Save the concept and view it in the Viewer. You should now see the Add button. \n<li>Edit the <tt>htmlTemplate</tt> property again to add a jQuery click handler for the Add button as shown below: \n<pre>\n  &lt;script&gt;\n    $(function() {\n      ...\n      // Process click on add button\n      $('#addBtn').click(function() {\n        $cjs.copyConcept({\n          puri: \"{{{listUri}}}\",\n          curi: \"{{{emptyContactUri}}}\",\n          done: function(newContact) {\n            $cjs.redirect(newContact.uri());\n          }, \n          fail: function() {\n            alert(\"Could not copy concept\");\n          }\n        });\n        return false;\n      });\n    });\n  &lt;/script&gt;\n</pre>\n<li>Edit the <tt>page</tt> property and set the propertyMap binding as shown below: \n<pre>\n   return {tableJson: JSON.stringify(tableJson), \n    listUri: home.uri(), \n    emptyContactUri: '[URI of the empty contact concept]'};\n</pre>\n<p>The property map now includes a listUri referring to the \"Custom Contacts Folder\" and an emptyContactUri referring to the \"Empty Contact\". Note that the emptyContactUri is from the first step. \n<li>Save the changes in the Editor. \n<li>Open the \"Custom Contacts Folder\" in the presentation mode. The Add button should now take you to an empty contact that you can modify. \n</ol>\n\n<p>The following video demonstrates the steps outlined above: \n\n<hr>\n<iframe src=\"//fast.wistia.net/embed/iframe/zu92sfm1xw?videoFoam=true\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen mozallowfullscreen webkitallowfullscreen oallowfullscreen msallowfullscreen width=\"854\" height=\"463\"></iframe><script src=\"//fast.wistia.net/assets/external/iframe-api-v1.js\"></script>\n</hr>\n\n<h3>Delete and discard buttons in the Contact page</h3>\n\n<p>\n\n<p>ConceptJS includes a user-defined lambda concept called \"Folder\". The Folder concept provides an easy way to navigate multiple concepts without using the IDE. \n\n<p>You can follow these steps to manage contacts inside a folder: <ol>\n<li>Open the \"Contact View\" lambda concept in the IDE. \n<li>Edit the <tt>htmlTemplate</tt> property and add the Discard and Delete buttons after the Save button as shown below. You can refer to <a href=\"http://codepen.io/lambdazen/pen/dPNvPj\" target=\"_blank\">this CodePen</a> to see a static mockup of these buttons. \n<pre>\n      &amp;emsp;\n      &lt;button type=\"submit\" class=\"btn btn-default\" id=\"discardBtn\"&gt;Discard&lt;/button&gt;\n      &lt;button type=\"submit\" class=\"btn btn-danger\" id=\"deleteBtn\" style=\"float: right\"&gt;Delete&lt;/button&gt;\n</pre>\n<li>Save the changes in the Editor. You should now see the two buttons when viewing any example concept in the Viewer.  \n<li>Edit the <tt>&lt;script&gt;</tt> tag inside the <tt>htmlTemplate</tt> property and change the script at the end to the following code: <pre>\n&lt;script&gt;\n  var viewModel = $cjs.ko(\"{{{uri}}}\");\n  ko.applyBindings(viewModel);\n\n  $(function() {\n    $(\"#saveBtn\").click(function() {\n      $cjs.session.save();\n      $cjs.redirect(\"{{{anchorUri}}}\");\n      return false;\n    });\n    $(\"#discardBtn\").click(function() {\n      $cjs.session.discard();\n      $cjs.redirect(\"{{{anchorUri}}}\");\n      return false;\n    });\n    $(\"#deleteBtn\").click(function() {\n      $cjs(\"{{{anchorUri}}}\").del();\n      $cjs.redirect(\"{{{contactListUri}}}\");\n      return false;\n    });\n  });\n&lt;/script&gt;\n</pre>\n<li>Edit the <tt>page</tt> property and modify the <tt>propertyMap</tt> script to pass the anchorUri and contactListUri as follows: <pre>\n  return {uri: home.prop('model').uri(), \n    anchorUri: home.anchor().uri(), \n    contactListUri: home.anchor().parent().uri()};\n</pre>\n<li>Save the changes in the Editor. \n<li>View an example concept in the presentation mode to test out the discard and delete buttons. \n</ol>\n\n<p>The following video demonstrates the steps outlined above: \n\n<hr>\n<iframe src=\"//fast.wistia.net/embed/iframe/j7v1j6l2e6?videoFoam=true\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen mozallowfullscreen webkitallowfullscreen oallowfullscreen msallowfullscreen width=\"854\" height=\"463\"></iframe><script src=\"//fast.wistia.net/assets/external/iframe-api-v1.js\"></script>\n<hr>\n\n<h4>How it works</h4>\n\n<p>The discard handler uses <tt>$cjs.session.discard()</tt> to remove the changes made by the Knockout model. After the changes are discarded, the page must be reloaded to show the original values in the text fields. This is done using the <tt>$cjs.redirect()</tt> method on the &ldquo;anchor URI&rdquo;, i.e., the URI of the concept without property lookups. \n\n<p>The delete script invokes the <tt>del()</tt> method on the anchor concept to remove it. Afterwards, the script redirects the browser to the contacts list. The contacts list URI is calculated as the parent of the anchor concept. \n\n<p>On the server side, the <tt>home.anchor().uri()</tt> object returns the object corresponding to the contact, without the '/contact' at the end. Similarly the <tt>home.anchor().parent()</tt> returns the parent concept of the contact, which is expected to be the Contacts folder. \n\n<h3>Recap</h3>\n\n<p>In the next unit, we will turn the Contact List into an exhibit that others can download and use. \n\n<ul class=\"recap\">\n<li>Continuations are lambda-concepts with a single lambda-property, called the input to the continuation. \n<li>A simple or lambda concept can establish an is-a relationship to a continuation concept. The platform will pass the former concept as an input to the latter continuation, and establish an is-a relationship from the former concept to the resulting binding. \n<li>Continuations are useful to improve performance, separate concerns (as in MVC architectures) and avoid cyclic dependencies. \n<li>Concepts can be programmatically added using the <tt>$cjs.copy()</tt> method which copies a given source concept under the given target parent concept. \n<li>Concepts can be programmatically deleted using the <tt>del()</tt> method in the concept object derived using <tt>$cjs(\"...uri..\")</tt>. \n<li>The <tt>$cjs.redirect(\"...uri...\")</tt> method lets you load a different concept in the browser given its URI.  \n</ul>\n\n"
    }
  }, {
    "name" : "_unit_number",
    "expr" : {
      "num" : 9
    }
  }, {
    "name" : "unit",
    "expr" : {
      "concept" : "local://vKVuPLJ9zC82y44Ofqyf85/",
      "conceptName" : "Course Unit",
      "bindings" : {
        "name" : "_unit_name",
        "content" : "_unit_content",
        "number" : "_unit_number"
      }
    }
  } ],
  "isas" : [ {
    "var" : "unit"
  } ],
  "isLambda" : false
}